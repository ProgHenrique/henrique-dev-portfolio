const [score, setScore]= useState(0);
  var gameInterval: string | number | NodeJS.Timer | undefined = undefined
  const [gameStarted, setGameStarted]= useState(false);
  const [gameOver, setGameOver]= useState(false);
  const [direction, setDirection] = useState('up')
  const [food, setFood] = useState({x: 10, y: 5})
  const [snake, setSnake] = useState([
    { x: 10, y: 12 },
    { x: 10, y: 13 },
    { x: 10, y: 14 },
    { x: 10, y: 15 },
    { x: 10, y: 16 },
    { x: 10, y: 17 },
    { x: 10, y: 18 },
    { x: 11, y: 18 },
    { x: 12, y: 18 },
    { x: 13, y: 18 },
    { x: 14, y: 18 },
    { x: 15, y: 18 },
    { x: 15, y: 19 },
    { x: 15, y: 20 },
    { x: 15, y: 21 },
    { x: 15, y: 22 },
    { x: 15, y: 23 },
    { x: 15, y: 24 },
  ])

  function startGame () {
    setGameStarted(true);
    gameInterval = setInterval(moveSnake, 50);
  }

  function restartGame () {

    setGameStarted(false)
    setGameOver(false)
    setScore(0)
    setFood({x: 10, y: 5})
    setSnake([
      { x: 10, y: 12 },
      { x: 10, y: 13 },
      { x: 10, y: 14 },
      { x: 10, y: 15 },
      { x: 10, y: 16 },
      { x: 10, y: 17 },
      { x: 10, y: 18 },
      { x: 11, y: 18 },
      { x: 12, y: 18 },
      { x: 13, y: 18 },
      { x: 14, y: 18 },
      { x: 15, y: 18 },
      { x: 15, y: 19 },
      { x: 15, y: 20 },
      { x: 15, y: 21 },
      { x: 15, y: 22 },
      { x: 15, y: 23 },
      { x: 15, y: 24 },
    ])

    setDirection('up')
    clearInterval(gameInterval);
    render()
  }

  function moveSnake () {
    let newX = snake[0].x
    let newY = snake[0].y
    switch (direction) {
      case "up":
        newY--;
        break;
      case "down":
        newY++;
        break;
      case "left":
        newX--;
        break;
      case "right":
        newX++;
        break;
    }

    if(
      newX >= 0 &&
      newX < 24 &&
      newY >= 0 &&
      newY < 40 &&
      snake.find(snakeCell => snakeCell.x === newX && snakeCell.y === newY)
    ){
      setSnake([{ x: newX, y: newY }, ...snake])

      if(newX === food.x && newY === food.y) {
        setScore(score + 1)
        setFood({x: Math.floor(Math.random() * 24), y: Math.floor(Math.random() * 40)})
      } else {
        snake.pop()
        setSnake([...snake])
      }
    } else {
      clearInterval(gameInterval)
      setGameStarted(false)
      setGameOver(true)
    }

    render()
  }

  function render() {
    const tableGame = document.getElementById('table-game')!
    tableGame.innerHTML = ""

    for (let h = 0; h < 40; h++) {
      for (let w = 0; w < 24; w++) {
        const cell = document.createElement('div')
        cell.style.width = '10px',
        cell.style.height = '10px',
        cell.style.display = "flex";
        cell.style.flexShrink = '0';
        cell.classList.add("black");

        if(w === food.x && h === food.y) {
          cell.style.backgroundColor = "#43D9AD";
          cell.style.borderRadius = "50%";
          cell.style.boxShadow = "0 0 10px #43D9AD";
        }

        let snakeCell = snake.find(snakeCell => snakeCell.x === w && snakeCell.y === h)
        if(snakeCell) {
          cell.style.backgroundColor = "#43D9AD";
          cell.style.opacity = String(1 - (snake.indexOf(snakeCell) / snake.length));
          cell.classList.add("green");
        }

        if(snakeCell && snake.indexOf(snakeCell) === 0) {
          let headRadius = '5px'
          if (direction === "up") {
            cell.style.borderTopLeftRadius = headRadius;
            cell.style.borderTopRightRadius = headRadius;
          }
          if (direction === "down") {

            cell.style.borderBottomLeftRadius = headRadius;
            cell.style.borderBottomRightRadius = headRadius;
          }
          if (direction === "left") {
            cell.style.borderTopLeftRadius = headRadius;
            cell.style.borderBottomLeftRadius = headRadius;
          }
          if (direction === "right") {
            cell.style.borderTopRightRadius = headRadius;
            cell.style.borderBottomRightRadius = headRadius;
          }
        }
        tableGame.appendChild(cell);
      }
      
    }
  }

  function move(newDirection: string) {
    switch (newDirection) {
      case "up": 
      if(direction !== 'down') {
          setDirection('up')
        }
        break
      case "down": 
      if(direction !== 'up') {
          setDirection('down')
        }
        break
      case "left": 
      if(direction !== 'right') {
          setDirection('left')
        }
        break
      case "right": 
      if(direction !== 'left') {
          setDirection('right')
        }
        break
    }
  }

  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if(gameStarted) {
        switch (event.key) {
          case 'ArrowLeft':
            if (direction !== "right") {
              setDirection("left")
            }
            break;
          case 'ArrowUp':
            if (direction !== "down") {
              setDirection("up")
            }
            break;
          case 'ArrowRight':
            if (direction !== "left") {
              setDirection("right")
            }
            break;
          case 'ArrowDown':
            if (direction !== "up") {
              setDirection("down")
            }
            break;
        }
      }
    };

    document.addEventListener("keydown", handleKeyDown);

    return () => {
      document.removeEventListener("keydown", handleKeyDown);
    };
  }, [gameStarted, gameOver, direction]);

  return (
    <>
      <TableGame id="table-game"></TableGame>
      <button onClick={startGame}>start-game</button>
      <button onClick={restartGame}>restart-game</button>
    </>
    
  )